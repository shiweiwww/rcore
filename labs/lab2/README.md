### lab2实验报告
 ##### 一. 实验目的和内容
  - ###### 动态内存分配
  - ###### 物理内存探测
  - ###### 物理页内存管理
 
 
 ##### 二. 操作方法和实验步骤
  - ###### 通过objdump -x 查看kernel_end和lab2中的KERNEL_END_ADDRESS输出对比是一致的
  - ###### 动态内存分配可以根据程序运行时状态修改内存申请的大小，要让内核中支持动态内存分配，必须实现rust的Trait GlobalAlloc的alloc和dealloc方法，实验中是直接使用的已开发的包buddy_system_allocator，更具体的实现参考[博客](https://os.phil-opp.com/kernel-heap/)
  - ###### riscv中opensi自动完成包括物理内存在内的各外设的扫描，并将结果以DTB格式保存，其地址保存在a1寄存器中。QEMU默认的DRAM物理内存地址范围为[0x80000000, 0x88000000)，通过lds脚本中的kernel_end即可知道内核结束的地址，对整个内存分布有了初步了解
  - ###### 为了更好的管理物理内存减少外碎片提高内存使用率，以4kb为一页，代码中FrameTracker用来进行物理页管理和FrameAllocator分配器用来进行物理页的分配和回收，FrameAllocator<T: Allocator>中的泛型T要求实现Allocator trait,而Allocator trait可以看成是页面分配算法的抽象，通过impl Allocator来实现物理页分配算法，如线段树等
  - ###### 汇编练习没什么大的改变，只不过打印了下kernel_end的地址
  - ###### 实验
    * ##### 暂未开始做，先刷一遍熟悉下
 
 ##### 三. 实验结果和分析
  - ###### .bss 字段是什么含义？为什么我们要将动态分配的内存（堆）空间放在 .bss 字段？
    * ###### .bss通常是指用来存放程序中未初始化的全局变量的一块内存区域,属于静态内存分配，这个不是必须的，也可以把动态分配的内存放在[kernel_end,kernel_end+KERNEL_HEAP_SIZE]，放在.bss段其实就和内核放在一起了，把kernel_end以后的地址给进程用了，而放在[kernel_end,kernel_end+KERNEL_HEAP_SIZE]，建立页表的时候需要清楚起始地址是kernel_end+KERNEL_HEAP_SIZE就行
  - ###### 我们在动态内存分配中实现了一个堆，它允许我们在内核代码中使用动态分配的内存，例如 Vec Box 等。那么，如果我们在实现这个堆的过程中使用 Vec 而不是 [u8]，会出现什么结果？
    * ###### 堆的实现需要Vec，而Vec的建立又要使用堆，会造成死循环

 ##### 四. 问题建议以及改进的地方
  - ###### 第一遍看对各个结构的设计有些懵懂混乱，写实验报告的时候回想了下整个过程，感觉设计很精妙，唯一不足的是buddy_system_allocator的实现细节还没去看，后期补下
  - ###### 以前做ucore的时候对内存总是很懵懂，做完lab2对内存这块算是有了清楚的认识，弥补了知识盲点 
  - ###### 实验题目前先不做，先刷一遍整体对代码有理解在刷吧


