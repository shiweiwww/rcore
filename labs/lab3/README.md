### lab3实验报告
 ##### 一. 实验目的和内容
  - ###### 虚拟地址和物理地址
  - ###### 页表实现
 
 ##### 二. 操作方法和实验步骤
  - ###### 虚拟地址和物理地址
    * ###### Sv39模式下，物理地址56位，0-11是offset，12-55位为物理页号ppn。对虚拟地址64位，0-11位offset，12-38位为虚拟页号vpn。Sv39 模式里面的一个页表项大小为 64 位（即 8 字节）。其中第 53-10 共 44 位为一个物理页号，表示这个虚拟页号映射到的物理页号。后面的第 9-0 位则描述页的相关状态信息。 页表的基址（起始地址）保存在一个特殊的寄存器satp中
  - ###### 页表实现
    * ###### Sv39模式下需要三级页表才可以从虚拟地址映射到物理地址，虚拟地址12-38位每9位一组划分成vpn2,vpn1,vnp0,从satp中获取第3三级页表的物理页号(satp的0-43位)base,得到对应的物理地址为：[{[(base<<12+vpn2*8)>>10 & 0xfffffffffff)<<12+vpn1*8]>>10 & 0xfffffffffff}>>10 & 0xfffffffffff]<<12 + offset(虚拟地址0-11位)。
  - ###### 启动程序，执行如下代码，通过i虚拟地址Debug调试下i的物理地址
        ```
            let i:f64=0x12345678;
            loop{};
        ```
  - ###### 实验
    * ##### 暂未开始做，先刷一遍熟悉下
 
 ##### 三. 实验结果和分析
  - ###### 代码流程分析 
      * ###### PageTableEntry页表项主要是设置页表项各个bit的设置
      * ###### PageTable是页表一个类型为PageTableEntry大小为512的数组
      * ###### PageTableTracker用来管理页表PageTable
      * ###### Segment定义页表映射方式以及虚拟地址范围，主要考虑到内核是放在一段高虚拟地址空间，对所有的进程都一样的，所以线性映射就行，对用户程序而言，看到的虚拟地址空间是一样的(地址隔离)，即所有的用户程序虚拟地址空间开都是一样的，基于页分配方式去映射而非线性映射
      * ###### MemorySet封装了映射关系mapping以及要映射的段segments，segments是个Vec<Segment>，Memoryset::new_kernel中把各个内核段text_start，rodata_start，data_start，bss_start封装成Segment并push到segments中，同时初始化mapping。mapping.map进行映射，先是mapping.find查找虚拟页号对应的页表项，页表项为空，则新建页表，并填充页表项，进入下一级页表，执行同样的操作，注意的是页表的查询是用了虚拟地址了，页表项中是物理页号，计算下一级页表base时候转换成虚拟地址才行。

 ##### 四. 问题建议以及改进的地方
  - ###### Debug 时候gdb发现无法查看物理内存，给调试页表带来不便
  - ###### rust语法的还是不是很熟练，昨晚lab3同时补了不少rust Deref，From，Into以及宏的语法知识
  - ###### 目前页面置换算法没去做，涉及到进程线程，后面实验在补上
  - ###### 实验题目前先不做，先刷一遍整体对代码有理解在刷吧

